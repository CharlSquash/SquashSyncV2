{% extends "base.html" %}
{% load static %}

{% block title %}{{ page_title }} - SquashSync{% endblock %}

{% block extra_head %}
<style>
    /* Grid for both leaders and other players */
    .player-vote-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); /* Slightly narrower cards */
        gap: 1.5rem;
        margin-top: 1rem;
    }
    .player-card {
        border: 2px solid var(--bs-border-color); /* Updated variable */
        border-radius: 8px;
        background-color: var(--bs-body-bg); /* Updated variable */
        text-align: center;
        transition: all 0.2s ease;
        position: relative;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        padding-bottom: 10px; /* Reduced padding */
        min-height: 220px; /* Adjusted height */
    }
    .player-card:hover:not(.disabled):not(.saving) { /* Add :not selectors */
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: var(--bs-link-color); /* Updated variable */
    }
    .player-card.disabled { /* Style for when vote limit reached FOR OTHER CARDS */
        cursor: not-allowed;
        opacity: 0.7;
    }
    .player-card.saving { /* Indicate saving state */
         cursor: wait;
         opacity: 0.8;
    }
    .player-card-content { padding: 1rem 1rem 0.5rem 1rem; flex-grow: 1; }
    .player-photo img, .player-photo .photo-placeholder {
        width: 80px; height: 80px; border-radius: 50%; margin: 0 auto 0.75rem; display: block;
        background-color: var(--bs-secondary-bg); /* Updated variable */
        border: 2px solid var(--bs-border-color-translucent); /* Updated variable */
    }
    .player-photo img { object-fit: cover; object-position: top; }
    .photo-placeholder { display: flex; align-items: center; justify-content: center; }
    .photo-placeholder .bi { font-size: 2.5rem; color: #adb5bd; }
    .player-name { font-weight: 600; font-size: 1rem; margin-bottom: 0.25rem; }

    /* Score Badge */
    .player-score-badge {
        position: absolute; top: 10px; right: 10px; background-color: var(--bs-primary);
        color: white; border-radius: 50%; width: 28px; height: 28px;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 0.8em;
    }
    /* Vote Details (collapsible) - Removed as detailed voter list isn't needed now */

    /* Vote Highlighting */
    .player-card.voted-by-user {
        border-color: var(--bs-success); /* Green border */
        background-color: var(--bs-success-bg-subtle);
    }
    html.dark-mode .player-card.voted-by-user {
       background-color: #032816; /* Keep dark mode subtle green */
       border-color: #20c997;
    }

    /* Spinner */
    .vote-spinner { position: absolute; top: 5px; left: 5px; width: 20px; height: 20px; border: 2px solid rgba(var(--bs-primary-rgb), 0.3); border-top-color: var(--bs-primary); border-radius: 50%; animation: spin 1s linear infinite; display: none; }
    .player-card.saving .vote-spinner { display: block; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Other Eligible Players Section */
    .other-players-section { margin-top: 3rem; }
    .search-input { max-width: 400px; margin-bottom: 1rem; }

    /* Winner Display */
    .winner-banner { background-color: var(--bs-success-bg-subtle); border-left: 5px solid var(--bs-success); padding: 1rem; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 1rem;}
    .winner-banner i { font-size: 2rem; color: var(--bs-success); }
    .winner-banner strong { font-size: 1.2rem; }

    /* Vote Counter */
    #vote-counter {
        font-weight: bold;
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        background-color: var(--bs-secondary-bg);
        border: 1px solid var(--bs-border-color);
        display: inline-block; /* Makes background fit content */
        margin-top: 5px; /* Add some space */
    }
    #vote-counter.limit-reached {
        background-color: var(--bs-warning-bg-subtle);
        border-color: var(--bs-warning-border-subtle);
        color: var(--bs-warning-text);
    }
    /* Simple feedback message styling */
    .vote-feedback {
        position: absolute; bottom: 5px; left: 5px; right: 5px; font-size: 0.75rem;
        padding: 2px 5px; border-radius: 3px; opacity: 0; transition: opacity 0.5s ease-out;
        z-index: 10; /* Ensure it's above other elements if needed */
        text-align: center; /* Center the text */
        /* Will be styled further by JS */
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4" id="awards-vote-page" data-prize-id="{{ prize.id }}" data-cast-vote-url="{% url 'awards:cast_vote_ajax' %}">
    {# --- Header & Prize Info --- #}
    <div class="d-flex justify-content-between align-items-center mb-2">
        <div>
            <h1><i class="bi bi-person-check-fill me-2"></i>{{ page_title }}</h1>
            <p class="text-muted mb-1">{{ prize.description|default:"No description available." }}</p>
            <p class="mb-1"><strong>Status:</strong> {{ prize.get_status_display }}</p>
            {% if prize.voting_opens and prize.voting_closes %}
                <p class="mb-1"><strong>Voting Period:</strong> {{ prize.voting_opens|date:"d M Y H:i" }} to {{ prize.voting_closes|date:"d M Y H:i" }}</p>
            {% elif prize.voting_opens %}
                 <p class="mb-1"><strong>Voting Opens:</strong> {{ prize.voting_opens|date:"d M Y H:i" }}</p>
            {% elif prize.voting_closes %}
                 <p class="mb-1"><strong>Voting Closes:</strong> {{ prize.voting_closes|date:"d M Y H:i" }}</p>
            {% endif %}
        </div>
        <div>
            <a href="{% url 'awards:prize_list' %}?year={{ prize.year }}" class="btn btn-outline-secondary">
                <i class="bi bi-arrow-left"></i> Back to Prize List
            </a>
            {# Removed Edit Nominations link #}
        </div>
    </div>

    {# --- Winner Display --- #}
    {% if winner %}
    <div class="winner-banner rounded">
        <i class="bi bi-trophy-fill"></i>
        <div>
            <strong>Winner Decided: {{ winner.player.full_name }}</strong><br>
            Awarded on {{ winner.award_date|date:"d M Y" }} by {{ winner.awarded_by.get_full_name|default:winner.awarded_by.username }}.
            (Final Score: {{ winner.final_score|default:"N/A" }})
        </div>
    </div>
    {% endif %}

    {# --- Voting Instructions / Status --- #}
    {% if not current_results and not eligible_not_voted_players.exists %} {# Check queryset directly #}
        <div class="alert alert-warning mt-4" role="alert">
            No players are currently eligible for this prize based on the criteria (Grade {{ prize.min_grade|default:"Any" }} - {{ prize.max_grade|default:"Any" }}).
        </div>
    {% elif not voting_allowed and not winner %}
       <div class="alert alert-info mt-4" role="alert">
           Voting is not currently open. {% comment %} Check if prize.voting_opens exists before comparing {% endcomment %}
           {% now "Y-m-d H:i:s" as current_datetime_str %} {# Get current time as string for comparison if needed #}
           {% if prize.voting_opens and prize.voting_opens|date:"Y-m-d H:i:s" > current_datetime_str %}It starts {{ prize.voting_opens|date:"d M Y H:i" }}.
           {% elif prize.voting_closes and prize.voting_closes|date:"Y-m-d H:i:s" < current_datetime_str %} It closed {{ prize.voting_closes|date:"d M Y H:i" }}.
           {% else %} Check prize status or dates. {% endif %}
       </div>
    {% elif voting_allowed %}
        <p class="lead mt-3">Click on a player's card to cast or remove your vote.</p>
        <p>You can cast up to 3 votes in total for this prize.
            {# Display initial count from view, JS will update it #}
            <span id="vote-counter">Votes Used: {{ user_vote_count }} / 3</span>
        </p>
    {% endif %}


    {# --- Current Leaders Section --- #}
    {% if current_results %}
        <h3 class="mt-4">Current Leaders</h3>
        <div class="player-vote-grid" id="leaders-grid">
            {% for result in current_results %} {# result is {'player': Player, 'score': int} #}
                <div class="player-card" data-player-id="{{ result.player.id }}" tabindex="0">
                    <div class="player-score-badge" id="score-{{ result.player.id }}">{{ result.score }}</div>
                    <div class="vote-spinner" id="spinner-{{ result.player.id }}"></div>
                    <div class="player-card-content">
                        <div class="player-photo">
                            {% if result.player.photo %}
                                <img src="{{ result.player.photo.url }}" alt="Photo of {{ result.player.full_name }}">
                            {% else %}
                                <div class="photo-placeholder"><i class="bi bi-person-fill"></i></div>
                            {% endif %}
                        </div>
                        <div class="player-name">{{ result.player.full_name }}</div>
                        {# Removed vote details list #}
                    </div> {# End player-card-content #}
                    {# Feedback div will be added by JS #}
                </div> {# End player-card #}
            {% endfor %}
        </div>
    {% endif %} {# End if current_results #}


    {# --- Other Eligible Players Section --- #}
    {% if eligible_not_voted_players.exists %} {# Check queryset directly #}
        <div class="other-players-section">
            <h3 class="mt-4">Other Eligible Players</h3>
            <input type="text" id="player-search" class="form-control search-input" placeholder="Search eligible players...">
            <div class="player-vote-grid" id="other-players-grid">
                {% for player in eligible_not_voted_players %}
                    <div class="player-card" data-player-id="{{ player.id }}" tabindex="0" data-player-name="{{ player.full_name|lower }}">
                        <div class="player-score-badge" id="score-{{ player.id }}">0</div>
                        <div class="vote-spinner" id="spinner-{{ player.id }}"></div>
                        <div class="player-card-content">
                            <div class="player-photo">
                                {% if player.photo %}
                                    <img src="{{ player.photo.url }}" alt="Photo of {{ player.full_name }}">
                                {% else %}
                                    <div class="photo-placeholder"><i class="bi bi-person-fill"></i></div>
                                {% endif %}
                            </div>
                            <div class="player-name">{{ player.full_name }}</div>
                            {# No vote details initially #}
                        </div> {# End player-card-content #}
                         {# Feedback div will be added by JS #}
                    </div> {# End player-card #}
                {% endfor %}
            </div>
        </div>
    {% endif %} {# End if eligible_not_voted_players #}


    {# --- Admin Winner Confirmation Section --- #}
    {# Use the simple boolean flag passed from the view #}
    {% if show_admin_confirm_section %}
        <hr class="my-5">
        <div class="card shadow-sm mt-4 bg-light">
            <div class="card-header bg-secondary text-white">
                <i class="bi bi-award-fill me-1"></i> Admin: Confirm Winner
            </div>
            <div class="card-body">
                <form method="post" action="{% url 'awards:confirm_winner' prize.id %}">
                    {% csrf_token %}
                    <p>Select the final winner for this prize based on votes or admin decision:</p>
                    {% comment %} Combine results and other players for the selection list {% endcomment %}
                    {% if not current_results and not eligible_not_voted_players.exists %}
                         <p class="text-danger">No eligible players to choose from.</p>
                    {% else %}
                        {% for result in current_results %}
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="radio" name="winner_player_id"
                                       id="winner_{{ result.player.id }}" value="{{ result.player.id }}" required>
                                <label class="form-check-label" for="winner_{{ result.player.id }}">
                                    {{ result.player.full_name }} (Current Score: {{ result.score }})
                                </label>
                            </div>
                        {% endfor %}
                        {% for player in eligible_not_voted_players %}
                             <div class="form-check mb-2">
                                <input class="form-check-input" type="radio" name="winner_player_id"
                                       id="winner_{{ player.id }}" value="{{ player.id }}" required>
                                <label class="form-check-label" for="winner_{{ player.id }}">
                                    {{ player.full_name }} (Current Score: 0)
                                </label>
                            </div>
                        {% endfor %}

                        <button type="submit" class="btn btn-success mt-3"
                                onclick="return confirm('Are you sure you want to confirm this winner? This will change the prize status to Decided and close voting.')">
                            <i class="bi bi-check-circle-fill me-1"></i> Confirm Winner & Close Voting
                        </button>
                    {% endif %} {# End check if players exist #}
                </form>
            </div>
        </div>
    {% endif %} {# End Admin Winner Section #}


</div> {# End container #}

{# Pass initial user votes to JavaScript #}
{{ user_votes_simple_json|json_script:"user-votes-data" }}
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- Basic setup ---
    console.log("Vote JS Initializing..."); // DEBUG
    const pageContainer = document.getElementById('awards-vote-page');
    if (!pageContainer) {
        console.error("Vote page container not found!");
        return;
    }

    const prizeId = pageContainer.dataset.prizeId;
    const castVoteUrl = pageContainer.dataset.castVoteUrl;
    const leadersGrid = document.getElementById('leaders-grid');
    const otherPlayersGrid = document.getElementById('other-players-grid');
    const searchInput = document.getElementById('player-search');
    const voteCounterElement = document.getElementById('vote-counter');
    let userVotes = {}; // Stores { "player_id_string": 1 } if voted by current user
    let userVoteCount = 0; // Current user's vote count for this prize
    const votingAllowed = {{ voting_allowed|yesno:"true,false" }};
    console.log(`Voting Allowed: ${votingAllowed}`); // DEBUG

    // --- CSRF Token ---
    function getCookie(name) {
        let cookieValue = null; if (document.cookie && document.cookie !== '') { const cookies = document.cookie.split(';'); for (let i = 0; i < cookies.length; i++) { const cookie = cookies[i].trim(); if (cookie.substring(0, name.length + 1) === (name + '=')) { cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; } } } return cookieValue;
    }
    const csrfToken = getCookie('csrftoken');
    if (!csrfToken) {
        console.error("CSRF token not found!");
        // Maybe display an error to the user?
    }

    // --- Initialization: Prioritize JSON, then fallback ---
    let initialCountSource = "unknown"; // For debugging
    try {
        const votesDataElement = document.getElementById('user-votes-data');
        if (votesDataElement) {
             const parsedVotes = JSON.parse(votesDataElement.textContent);
             // Basic validation: Check if it's an object
             if (typeof parsedVotes === 'object' && parsedVotes !== null) {
                 userVotes = parsedVotes;
                 // *** FIX: Calculate count directly from parsed object ***
                 userVoteCount = Object.keys(userVotes).length;
                 initialCountSource = "JSON";
                 console.log("Initial user votes loaded from JSON:", userVotes); // DEBUG
                 console.log(`Initial user vote count derived from JSON: ${userVoteCount}`); // DEBUG
             } else {
                 console.warn("Parsed votes data is not a valid object:", parsedVotes);
                 throw new Error("Invalid votes data format"); // Trigger fallback
             }
        } else {
            console.warn("User votes data script tag not found.");
            throw new Error("Votes data element missing"); // Trigger fallback
        }
    } catch (e) {
        console.error("Could not parse initial user votes data from JSON:", e);
        // Fallback: Try reading initial count from the span
        if (voteCounterElement) {
             // Match the pattern "Votes Used: X / 3"
             const match = voteCounterElement.textContent.match(/Votes Used:\s*(\d+)\s*\/\s*3/);
             if (match && match[1]) {
                 userVoteCount = parseInt(match[1], 10);
                 initialCountSource = "Fallback Span";
                 console.log(`Fallback: Initialized userVoteCount from span: ${userVoteCount}`); // DEBUG
                 // Cannot reliably reconstruct userVotes object here, so leave it empty
                 userVotes = {};
                 console.warn("Could not reconstruct specific votes from fallback count.");
             } else {
                  console.error("Could not parse initial count from span during fallback."); // DEBUG
                  userVoteCount = 0; // Default to 0 if everything fails
                  initialCountSource = "Fallback Failed -> 0";
             }
        } else {
             console.error("Vote counter element not found during fallback."); // DEBUG
             userVoteCount = 0; // Default to 0
             initialCountSource = "Fallback Failed -> 0";
        }
    }
    console.log(`Final Initial Count: ${userVoteCount} (Source: ${initialCountSource})`); // DEBUG
    updateVoteCounterUI(); // Update counter display and card states on load using the determined initial count


    function initializeCards(grid) {
        if (!grid) return;
        grid.querySelectorAll('.player-card').forEach(card => {
            const playerIdStr = card.dataset.playerId; // Keep as string for consistency with userVotes keys
            if (!playerIdStr) {
                console.warn("Card found without player ID:", card);
                return;
            }
            updateCardVoteState(card, playerIdStr); // Apply initial visual state

            if (votingAllowed) {
                card.addEventListener('click', (event) => {
                    handleCardClick(card, playerIdStr);
                });
            } else {
                 card.style.cursor = 'default'; // No pointer if voting closed
                 card.classList.add('disabled'); // Visually disable if voting closed
            }
        });
    }

    // --- UI Update Functions ---
    function updateCardVoteState(card, playerIdStr) {
        // State depends *only* on the current JS variables userVotes and userVoteCount
        const hasVoted = userVotes.hasOwnProperty(playerIdStr);
        card.classList.toggle('voted-by-user', hasVoted);

        // Disable clicking OTHER cards if limit is reached and this card ISN'T voted
        const limitReached = userVoteCount >= 3;
        const isDisabled = limitReached && !hasVoted;
        card.classList.toggle('disabled', isDisabled);

        // Update cursor based on voting allowance and state
        if (votingAllowed) {
            // If it's disabled (limit reached for others), not-allowed cursor
            // If it's not disabled (either limit not reached, or this IS voted), pointer cursor
            card.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
        } else {
            card.style.cursor = 'default'; // Always default if voting closed
        }
        // console.log(`Updated card ${playerIdStr}: voted=${hasVoted}, disabled=${isDisabled}, count=${userVoteCount}`); // DEBUG - Can be noisy
    }

    function updateVoteCounterUI() {
        console.log(`Updating Vote Counter UI. Current JS Count: ${userVoteCount}`); // DEBUG
        if (voteCounterElement) {
            voteCounterElement.textContent = `Votes Used: ${userVoteCount} / 3`;
            const limitReached = userVoteCount >= 3;
            voteCounterElement.classList.toggle('limit-reached', limitReached);
            console.log(`Counter element updated. Limit reached: ${limitReached}`); // DEBUG
        } else {
             console.warn("Vote counter element not found!"); // DEBUG
        }
        // Update disabled state for ALL cards based on the new count
        console.log("Updating disabled state for all cards..."); // DEBUG
        [leadersGrid, otherPlayersGrid].forEach(grid => {
            if (!grid) return;
            grid.querySelectorAll('.player-card').forEach(card => {
                const playerIdStr = card.dataset.playerId;
                if (playerIdStr) { // Check if playerIdStr exists
                     updateCardVoteState(card, playerIdStr); // Re-apply state based on new count
                }
            });
        });
        console.log("Card disabled states updated."); // DEBUG
    }

     // --- Feedback Message ---
     function showTemporaryMessage(card, message, isError = false) {
        let feedbackEl = card.querySelector('.vote-feedback');
        if (!feedbackEl) {
            feedbackEl = document.createElement('div');
            feedbackEl.className = 'vote-feedback';
            card.appendChild(feedbackEl); // Append inside the card
        }

        // Clear previous timeouts if any
        if (feedbackEl.timeoutId) {
            clearTimeout(feedbackEl.timeoutId);
        }

        console.log(`Showing feedback on card ${card.dataset.playerId}: "${message}" (Error: ${isError})`); // DEBUG
        feedbackEl.textContent = message;
        feedbackEl.style.backgroundColor = isError ? 'var(--bs-danger-bg-subtle)' : 'var(--bs-success-bg-subtle)';
        feedbackEl.style.color = isError ? 'var(--bs-danger-text)' : 'var(--bs-success-text)';
        feedbackEl.style.borderColor = isError ? 'var(--bs-danger-border-subtle)' : 'var(--bs-success-border-subtle)'; // Optional border
        feedbackEl.style.border = '1px solid';

        // Use requestAnimationFrame to ensure styles are applied before starting transition
        requestAnimationFrame(() => {
            requestAnimationFrame(() => { // Double RAF to be safe across browsers
                 feedbackEl.style.opacity = '1';
            });
        });


        feedbackEl.timeoutId = setTimeout(() => {
            feedbackEl.style.opacity = '0';
            feedbackEl.timeoutId = null; // Clear the stored ID
        }, 2500); // Hide after 2.5 seconds
    }


    // --- Event Handlers & AJAX ---
    function handleCardClick(card, playerIdStr) {
        console.log(`Card clicked: Player ID ${playerIdStr}`); // DEBUG
        if (!votingAllowed || card.classList.contains('saving')) {
            console.log("Click ignored: Voting not allowed or card is saving."); // DEBUG
            return;
        }

        // Check based on CURRENT JS state
        const hasVoted = userVotes.hasOwnProperty(playerIdStr);
        console.log(`Has voted for ${playerIdStr}? ${hasVoted}. Current count: ${userVoteCount}`); // DEBUG


        // Prevent casting vote if limit reached AND clicking a NEW player
        if (userVoteCount >= 3 && !hasVoted) {
            console.log("Vote limit reached, cannot vote for new player."); // DEBUG
            showTemporaryMessage(card, "Vote limit reached! Remove another vote first.", true);
            return; // Stop processing
        }

        // Determine action: always remove if already voted, otherwise cast
        const action = hasVoted ? 'remove' : 'cast';
        console.log(`Determined action: ${action}`); // DEBUG


        sendVoteUpdate(card, parseInt(playerIdStr), action); // Send integer ID to backend
    }

    async function sendVoteUpdate(card, playerIdInt, action) {
        console.log(`Sending AJAX request: Action=${action}, PlayerID=${playerIdInt}`); // DEBUG
        card.classList.add('saving'); // Show spinner
        try {
            const response = await fetch(castVoteUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken, 'Accept': 'application/json' },
                body: JSON.stringify({ prize_id: prizeId, player_id: playerIdInt, action: action }), // Send integer ID
            });

            console.log(`AJAX Response Status: ${response.status}`); // DEBUG

             // Check if response is ok and is JSON
             if (!response.ok) {
                 let errorMsg = `Server error: ${response.status}`;
                 try {
                     // Try to get more specific error from server JSON response
                     const errorData = await response.json();
                     errorMsg = errorData.message || errorMsg;
                     console.error("Server returned error:", errorData); // DEBUG
                 } catch (e) { console.error("Could not parse error response body:", e); /* Ignore if response wasn't JSON */ }
                 throw new Error(errorMsg); // Throw error to be caught below
             }

            const data = await response.json(); // Now safe to parse
            console.log("AJAX Success Response Data:", data); // DEBUG


            if (data.status === 'success') {
                // --- Update Local State FIRST based *only* on Server Response ---
                const playerIdStr = String(playerIdInt); // Convert back to string for JS object key

                // CRITICAL: Update JS count *from server response*
                userVoteCount = data.user_vote_count;
                console.log(`Local userVoteCount updated to: ${userVoteCount} (from server response)`); // DEBUG

                // Update the userVotes object based on the ACTUAL reported state ('voted' key)
                if (data.voted === true) { // Server says user *now* has a vote for this player
                    if (!userVotes.hasOwnProperty(playerIdStr)) {
                         userVotes[playerIdStr] = 1; // Add if not present
                         console.log(`Synced local userVotes: Added ${playerIdStr} based on server 'voted: true'.`); // DEBUG
                    } else {
                         console.log(`Synced local userVotes: ${playerIdStr} already present, matches server 'voted: true'.`); // DEBUG
                    }
                } else { // Server says user *does not* have a vote for this player now
                    if (userVotes.hasOwnProperty(playerIdStr)) {
                        delete userVotes[playerIdStr]; // Remove if present
                        console.log(`Synced local userVotes: Removed ${playerIdStr} based on server 'voted: false'.`); // DEBUG
                    } else {
                         console.log(`Synced local userVotes: ${playerIdStr} already absent, matches server 'voted: false'.`); // DEBUG
                    }
                }
                 console.log("Final updated local userVotes:", userVotes); // DEBUG


                 // --- Update UI Based on New State ---
                // 1. Update the counter display and disability state of ALL cards
                 console.log("Calling updateVoteCounterUI after successful vote sync..."); // DEBUG
                updateVoteCounterUI(); // This now uses the count received from the server

                // 2. Update score badge for the specific card
                const scoreBadge = card.querySelector('.player-score-badge');
                if (scoreBadge && data.new_score !== undefined) {
                    scoreBadge.textContent = data.new_score;
                     console.log(`Updated score badge for ${playerIdStr} to ${data.new_score}`); // DEBUG
                }

                // 3. Show success/info message from server
                showTemporaryMessage(card, data.message); // Server message tells user what happened (e.g., "Vote removed", "Already voted")

                 // --- Optional: Move card between grids (implement later if needed) ---

            } else if (data.status === 'limit_reached') {
                 console.log("Server reported vote limit reached."); // DEBUG
                 showTemporaryMessage(card, data.message, true); // Show limit message as error
                 // Trust the server's count when limit is hit
                 userVoteCount = data.user_vote_count !== undefined ? data.user_vote_count : 3;
                 console.log(`Set userVoteCount to ${userVoteCount} based on server limit response.`); // DEBUG
                 console.log("Calling updateVoteCounterUI after limit reached..."); // DEBUG
                 updateVoteCounterUI(); // Update UI states to reflect limit
            } else {
                 // Handle other specific errors reported by the server (e.g., 'error')
                 console.error("Server returned non-success status:", data); // DEBUG
                 throw new Error(data.message || 'Unknown error from server.');
            }
        } catch (error) {
            console.error("Error casting vote (AJAX catch block):", error); // DEBUG
            showTemporaryMessage(card, `Error: ${error.message || 'Could not save vote.'}`, true);
             // We don't revert state here, rely on refresh or next successful action to sync
        } finally {
            card.classList.remove('saving'); // Hide spinner
             console.log(`AJAX complete for ${playerIdInt}. Removed 'saving' class.`); // DEBUG

        }
    }


    // --- Search Filter ---
    function filterPlayers() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        if (!otherPlayersGrid) return;
        otherPlayersGrid.querySelectorAll('.player-card').forEach(card => {
            const playerName = card.dataset.playerName || '';
            const isVisible = playerName.includes(searchTerm);
            card.style.display = isVisible ? 'flex' : 'none'; // Use flex for display type
        });
    }

    if (searchInput) {
        searchInput.addEventListener('input', filterPlayers);
    }

    // --- Run Initialization ---
    console.log("Initializing cards..."); // DEBUG
    initializeCards(leadersGrid);
    initializeCards(otherPlayersGrid);
    console.log("Card initialization complete."); // DEBUG


});
</script>
{% endblock %}

