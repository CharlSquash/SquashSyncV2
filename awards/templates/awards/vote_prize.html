{# awards/templates/awards/vote_prize.html #}
{% extends "base.html" %}
{% load static %}

{% block title %}{{ page_title }} - SquashSync{% endblock %}

{% block extra_head %}
<style>
    /* Grid for both leaders and other players */
    .player-vote-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); /* Adjusted minmax */
        gap: 1.5rem;
        margin-top: 1rem;
    }
    .player-card {
        border: 2px solid var(--bs-border-color);
        border-radius: 8px;
        background-color: var(--bs-body-bg);
        text-align: center;
        transition: all 0.2s ease;
        position: relative;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        padding-bottom: 30px; /* Space for feedback message */
        min-height: 220px; /* Ensure cards have a minimum height */
    }
    .player-card:hover:not(.is-disabled-interaction):not(.saving) {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: var(--bs-primary); /* Use primary color for hover */
    }
    .player-card.is-disabled-interaction {
        cursor: not-allowed !important;
        opacity: 0.65;
        background-color: var(--bs-secondary-bg);
    }
    .player-card.saving {
         cursor: wait;
         opacity: 0.8;
    }
    .player-card-content { padding: 1rem 1rem 0.5rem 1rem; flex-grow: 1; }
    .player-photo img, .player-photo .photo-placeholder {
        width: 80px; height: 80px; border-radius: 50%; margin: 0 auto 0.75rem; display: block;
        background-color: var(--bs-secondary-bg);
        border: 2px solid var(--bs-border-color-translucent);
    }
    .player-photo img { object-fit: cover; object-position: top; }
    .photo-placeholder { display: flex; align-items: center; justify-content: center; }
    .photo-placeholder .bi { font-size: 2.5rem; color: var(--bs-secondary-color); }
    .player-name { font-weight: 600; font-size: 1rem; margin-bottom: 0.25rem; }

    /* Score Badge */
    .player-score-badge {
        position: absolute; top: 10px; right: 10px; background-color: var(--bs-primary);
        color: white; border-radius: 50%; width: 28px; height: 28px;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 0.8em;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    /* Vote Highlighting */
    .player-card.voted-by-user {
        border-color: var(--bs-success); /* Green border */
        background-color: var(--bs-success-bg-subtle);
    }
    html.dark-mode .player-card.voted-by-user {
       background-color: #032816;
       border-color: #20c997;
    }
    /* Spinner */
    .vote-spinner { position: absolute; top: 5px; left: 5px; width: 20px; height: 20px; border: 2px solid rgba(var(--bs-primary-rgb), 0.3); border-top-color: var(--bs-primary); border-radius: 50%; animation: spin 1s linear infinite; display: none; }
    .player-card.saving .vote-spinner { display: block; }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Search */
    .search-input { max-width: 400px; margin-bottom: 1rem; }
    /* Winner */
    .winner-banner { background-color: var(--bs-success-bg-subtle); border-left: 5px solid var(--bs-success); padding: 1rem; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 1rem;}
    .winner-banner i { font-size: 2rem; color: var(--bs-success); }
    .winner-banner strong { font-size: 1.2rem; }
    /* Vote Counter */
    #vote-counter {
        font-weight: bold; padding: 0.3rem 0.6rem; border-radius: 4px;
        background-color: var(--bs-secondary-bg); border: 1px solid var(--bs-border-color);
        display: inline-block; margin-top: 5px; transition: all 0.3s ease;
    }
    #vote-counter.limit-reached {
        background-color: var(--bs-warning-bg-subtle); border-color: var(--bs-warning-border-subtle);
        color: var(--bs-warning-text-emphasis);
    }
    /* Feedback Message */
    .vote-feedback {
        position: absolute; bottom: 5px; left: 5px; right: 5px; font-size: 0.75rem;
        padding: 2px 5px; border-radius: 3px; opacity: 0; transition: opacity 0.5s ease-out, background-color 0.2s, color 0.2s, border-color 0.2s;
        z-index: 10; text-align: center; border: 1px solid transparent;
        max-width: calc(100% - 10px); /* Ensure it doesn't overflow */
        box-sizing: border-box;
    }
    .vote-feedback.show { opacity: 1; }
    .vote-feedback.success { background-color: var(--bs-success-bg-subtle); color: var(--bs-success-text-emphasis); border-color: var(--bs-success-border-subtle); }
    .vote-feedback.error { background-color: var(--bs-danger-bg-subtle); color: var(--bs-danger-text-emphasis); border-color: var(--bs-danger-border-subtle); }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4" id="awards-vote-page"
     data-prize-id="{{ prize.id }}"
     data-cast-vote-url="{% url 'awards:cast_vote_ajax' prize.id %}"
     data-clear-votes-url="{% url 'awards:clear_my_votes_ajax' prize.id %}" {# Added clear votes URL #}
>
    {# --- Header & Prize Info --- #}
    <div class="d-flex justify-content-between align-items-center mb-2">
        <div>
            <h1><i class="bi bi-person-check-fill me-2"></i>{{ page_title }}</h1>
            <p class="text-muted mb-1">{{ prize.description|default:"No description available." }}</p>
            <p class="mb-1"><strong>Status:</strong> {{ prize.get_status_display }}</p>
            {% if prize.voting_opens and prize.voting_closes %}
                <p class="mb-1"><strong>Voting Period:</strong> {{ prize.voting_opens|date:"d M Y H:i" }} to {{ prize.voting_closes|date:"d M Y H:i" }}</p>
            {% elif prize.voting_opens %}
                 <p class="mb-1"><strong>Voting Opens:</strong> {{ prize.voting_opens|date:"d M Y H:i" }}</p>
            {% elif prize.voting_closes %}
                 <p class="mb-1"><strong>Voting Closes:</strong> {{ prize.voting_closes|date:"d M Y H:i" }}</p>
            {% endif %}
        </div>
        <div>
            <a href="{% url 'awards:prize_list' %}?year={{ prize.year }}" class="btn btn-outline-secondary">
                <i class="bi bi-arrow-left"></i> Back to Prize List
            </a>
        </div>
    </div>

    {# --- Winner Display --- #}
    {% if winner %}
    <div class="winner-banner rounded">
        <i class="bi bi-trophy-fill"></i>
        <div>
            <strong>Winner Decided: {{ winner.player.full_name }}</strong><br>
            Awarded on {{ winner.award_date|date:"d M Y" }} by {{ winner.awarded_by.get_full_name|default:winner.awarded_by.username }}.
            (Final Score: {{ winner.final_score|default:"N/A" }})
        </div>
    </div>
    {% endif %}

    {# --- Voting Instructions / Status --- #}
    {% if not current_results and not eligible_not_voted_players %} {# Check lists directly #}
        <div class="alert alert-warning mt-4" role="alert">
            No players are currently eligible for this prize based on the criteria (Grade {{ prize.get_min_grade_display|default:"Any" }} - {{ prize.get_max_grade_display|default:"Any" }}).
        </div>
    {% elif not voting_allowed and not winner %}
       <div class="alert alert-info mt-4" role="alert">
           Voting is not currently open.
           {% now "Y-m-d H:i:s" as current_datetime_str %}
           {% if prize.voting_opens and prize.voting_opens|date:"Y-m-d H:i:s" > current_datetime_str %}It starts {{ prize.voting_opens|date:"d M Y H:i" }}.
           {% elif prize.voting_closes and prize.voting_closes|date:"Y-m-d H:i:s" < current_datetime_str %} It closed {{ prize.voting_closes|date:"d M Y H:i" }}.
           {% else %} Check prize status or dates. {% endif %}
       </div>
    {% elif voting_allowed %}
        <p class="lead mt-3">Click on a player's card to cast or remove your vote.</p>
        <div class="d-flex align-items-center gap-2 mb-3"> {# Added margin bottom #}
            <span>You can cast up to 3 votes in total for this prize.</span>
            <span id="vote-counter">Votes Used: {{ user_vote_count }} / 3</span>
            {# --- Add the new button --- #}
            <button id="clear-my-votes-btn" class="btn btn-sm btn-outline-danger" title="Remove all your votes for this prize">
                <i class="bi bi-trash me-1"></i> Clear My Votes
            </button>
        </div>
    {% endif %}


    {# --- Current Leaders Section --- #}
    {% if current_results %}
        <h3 class="mt-4">Current Leaders</h3>
        <div class="player-vote-grid" id="leaders-grid">
            {% for result in current_results %} {# result is {'player': Player, 'score': int, 'voted_by_user': bool} #}
                <div class="player-card {% if result.voted_by_user %}voted-by-user{% endif %}" data-player-id="{{ result.player.id }}" tabindex="0">
                    <div class="player-score-badge" id="score-{{ result.player.id }}">{{ result.score }}</div>
                    <div class="vote-spinner" id="spinner-{{ result.player.id }}"></div>
                    <div class="player-card-content">
                        <div class="player-photo">
                            {% if result.player.photo %}
                                <img src="{{ result.player.photo.url }}" alt="Photo of {{ result.player.full_name }}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                <div class="photo-placeholder" style="display: none;"><i class="bi bi-person-fill"></i></div> {# Fallback placeholder #}
                            {% else %}
                                <div class="photo-placeholder"><i class="bi bi-person-fill"></i></div>
                            {% endif %}
                        </div>
                        <div class="player-name">{{ result.player.full_name }}</div>
                    </div>
                    <div class="vote-feedback" id="feedback-{{ result.player.id }}"></div>
                </div>
            {% endfor %}
        </div>
    {% endif %}


    {# --- Other Eligible Players Section --- #}
    {% if eligible_not_voted_players %} {# Check list directly #}
        <div class="other-players-section">
            <h3 class="mt-4">Other Eligible Players</h3>
            <input type="text" id="player-search" class="form-control search-input" placeholder="Search eligible players...">
            <div class="player-vote-grid" id="other-players-grid">
                {% for item in eligible_not_voted_players %} {# item is {'player': Player, 'score': int, 'voted_by_user': bool} #}
                    <div class="player-card {% if item.voted_by_user %}voted-by-user{% endif %}" data-player-id="{{ item.player.id }}" tabindex="0" data-player-name="{{ item.player.full_name|lower }}">
                        <div class="player-score-badge" id="score-{{ item.player.id }}">{{ item.score }}</div>
                        <div class="vote-spinner" id="spinner-{{ item.player.id }}"></div>
                        <div class="player-card-content">
                            <div class="player-photo">
                                {% if item.player.photo %}
                                    <img src="{{ item.player.photo.url }}" alt="Photo of {{ item.player.full_name }}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                    <div class="photo-placeholder" style="display: none;"><i class="bi bi-person-fill"></i></div> {# Fallback placeholder #}
                                {% else %}
                                    <div class="photo-placeholder"><i class="bi bi-person-fill"></i></div>
                                {% endif %}
                            </div>
                            <div class="player-name">{{ item.player.full_name }}</div>
                        </div>
                        <div class="vote-feedback" id="feedback-{{ item.player.id }}"></div>
                    </div>
                {% endfor %}
            </div>
        </div>
    {% endif %}


    {# --- Admin Winner Confirmation Section --- #}
    {% if show_admin_confirm_section %}
        <hr class="my-5">
        <div class="card shadow-sm mt-4 bg-light">
            <div class="card-header bg-secondary text-white">
                <i class="bi bi-award-fill me-1"></i> Admin: Confirm Winner
            </div>
            <div class="card-body">
                <form method="post" action="{% url 'awards:confirm_winner' prize.id %}">
                    {% csrf_token %}
                    <p>Select the final winner for this prize based on votes or admin decision:</p>
                    {% comment %} Combine results and other players for the selection list {% endcomment %}
                    {% if not current_results and not eligible_not_voted_players %}
                         <p class="text-danger">No eligible players to choose from.</p>
                    {% else %}
                        {# Sort combined list alphabetically for consistent radio button order #}
                        {% with all_eligible=current_results|add:eligible_not_voted_players %}
                        {% regroup all_eligible|dictsort:"player.last_name"|dictsort:"player.first_name" by player as player_list %}
                            {% for player_data in all_eligible %}
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="radio" name="winner_player_id"
                                           id="winner_{{ player_data.player.id }}" value="{{ player_data.player.id }}" required>
                                    <label class="form-check-label" for="winner_{{ player_data.player.id }}">
                                        {{ player_data.player.full_name }} (Current Score: {{ player_data.score }})
                                    </label>
                                </div>
                            {% endfor %}
                        {% endwith %}

                        <button type="submit" class="btn btn-success mt-3"
                                onclick="return confirm('Are you sure you want to confirm this winner? This will change the prize status to Decided and close voting.')">
                            <i class="bi bi-check-circle-fill me-1"></i> Confirm Winner & Close Voting
                        </button>
                    {% endif %}
                </form>
            </div>
        </div>
    {% endif %}


</div> {# End container #}

{# Pass initial user votes dictionary to JavaScript using json_script #}
{{ user_votes_data_dict|json_script:"user-votes-data" }}


{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- Basic setup ---
    console.log("Vote JS Initializing...");
    const pageContainer = document.getElementById('awards-vote-page');
    if (!pageContainer) {
        console.error("Vote page container not found!");
        return;
    }

    const prizeId = pageContainer.dataset.prizeId;
    const castVoteUrl = pageContainer.dataset.castVoteUrl;
    const clearVotesUrl = pageContainer.dataset.clearVotesUrl; // Get new URL
    const clearVotesBtn = document.getElementById('clear-my-votes-btn'); // Get new Button

    const leadersGrid = document.getElementById('leaders-grid');
    const otherPlayersGrid = document.getElementById('other-players-grid');
    const searchInput = document.getElementById('player-search');
    const voteCounterElement = document.getElementById('vote-counter');
    let userVotes = {}; // Stores { "player_id_string": 1 } if voted by current user
    let userVoteCount = 0; // Current user's vote count for this prize
    const votingAllowed = {{ voting_allowed|yesno:"true,false" }};
    console.log(`Initial Voting Allowed State (from Django): ${votingAllowed}`);

    // --- CSRF Token ---
    function getCookie(name) {
        let cookieValue = null; if (document.cookie && document.cookie !== '') { const cookies = document.cookie.split(';'); for (let i = 0; i < cookies.length; i++) { const cookie = cookies[i].trim(); if (cookie.substring(0, name.length + 1) === (name + '=')) { cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; } } } return cookieValue;
    }
    const csrfToken = getCookie('csrftoken');
    if (!csrfToken) console.error("CSRF token not found!");

    // --- Initialization: Load initial votes from JSON ---
    let initialCountSource = "unknown";
    try {
        const votesDataElement = document.getElementById('user-votes-data');
        if (votesDataElement) {
             const parsedVotes = JSON.parse(votesDataElement.textContent); // Parse from json_script content
             if (typeof parsedVotes === 'object' && parsedVotes !== null) {
                 userVotes = parsedVotes;
                 userVoteCount = Object.keys(userVotes).length;
                 initialCountSource = "JSON";
                 console.log("Initial user votes loaded from JSON:", userVotes, `Count: ${userVoteCount}`);
             } else { throw new Error("Invalid votes data format"); }
        } else { throw new Error("Votes data element missing"); }
    } catch (e) {
        console.error("Could not parse initial user votes data from JSON:", e);
        // Fallback using the displayed count
        if (voteCounterElement) {
             const match = voteCounterElement.textContent.match(/Votes Used:\s*(\d+)\s*\/\s*3/);
             userVoteCount = (match && match[1]) ? parseInt(match[1], 10) : 0;
             initialCountSource = "Fallback Span";
        } else { userVoteCount = 0; initialCountSource = "Fallback Failed -> 0"; }
        console.warn(`Using fallback count: ${userVoteCount} (Source: ${initialCountSource})`);
        userVotes = {}; // Cannot reconstruct specific votes from fallback count
    }
    updateVoteCounterUI(); // Update counter display and card states on load

    function initializeCards(grid) {
        if (!grid) return;
        grid.querySelectorAll('.player-card').forEach(card => {
            const playerIdStr = card.dataset.playerId;
            if (!playerIdStr) { console.warn("Card found without player ID:", card); return; }
            updateCardVoteState(card, playerIdStr); // Apply initial visual state
            if (votingAllowed) {
                card.addEventListener('click', () => handleCardClick(card, playerIdStr));
            } else {
                 card.classList.add('is-disabled-interaction'); // Disable if voting closed globally
            }
        });
    }

    // --- UI Update Functions ---
    function updateCardVoteState(card, playerIdStr) {
        const hasVoted = userVotes.hasOwnProperty(playerIdStr);
        card.classList.toggle('voted-by-user', hasVoted);
        const limitReached = userVoteCount >= 3;
        // Interaction disabled if voting closed OR (limit reached AND user hasn't voted for THIS player)
        const isDisabledInteraction = !votingAllowed || (limitReached && !hasVoted);

        if (isDisabledInteraction) {
            card.classList.add('is-disabled-interaction');
            card.style.cursor = 'not-allowed';
        } else {
            card.classList.remove('is-disabled-interaction');
            card.style.cursor = 'pointer';
        }
    }

    function updateVoteCounterUI() {
        if (voteCounterElement) {
            voteCounterElement.textContent = `Votes Used: ${userVoteCount} / 3`;
            const limitReached = userVoteCount >= 3;
            voteCounterElement.classList.toggle('limit-reached', limitReached);
        }
        if (clearVotesBtn) {
            // Disable clear button if user has no votes or voting is closed
            clearVotesBtn.disabled = (userVoteCount === 0 || !votingAllowed);
        }
        // Update disabled state for ALL cards based on the new count
        [leadersGrid, otherPlayersGrid].forEach(grid => {
            if (!grid) return;
            grid.querySelectorAll('.player-card').forEach(card => {
                const playerIdStr = card.dataset.playerId;
                if (playerIdStr) updateCardVoteState(card, playerIdStr);
            });
        });
    }

     function showTemporaryMessage(card, message, isError = false) {
        let feedbackEl = card.querySelector('.vote-feedback');
        if (!feedbackEl) { console.warn("Feedback element not found for card"); return; }
        if (feedbackEl.timeoutId) clearTimeout(feedbackEl.timeoutId);
        feedbackEl.textContent = message;
        feedbackEl.classList.remove('success', 'error', 'show');
        feedbackEl.classList.add(isError ? 'error' : 'success');
        requestAnimationFrame(() => { requestAnimationFrame(() => { feedbackEl.classList.add('show'); }); });
        feedbackEl.timeoutId = setTimeout(() => { feedbackEl.classList.remove('show'); feedbackEl.timeoutId = null; }, 2500);
    }

    // --- Event Handlers & AJAX ---
    function handleCardClick(card, playerIdStr) {
        if (!votingAllowed) return; // Ignore if voting is globally closed
        if (card.classList.contains('saving')) return; // Ignore if already processing

        // Re-check interaction status specifically for this card
        const limitReached = userVoteCount >= 3;
        const hasVoted = userVotes.hasOwnProperty(playerIdStr);
        const isDisabledInteraction = limitReached && !hasVoted; // Can't add more if limit reached and haven't voted for this one

        if (isDisabledInteraction) {
            showTemporaryMessage(card, "Vote limit reached! Remove another vote first.", true);
            return;
        }

        // Determine action based on whether user has voted for *this* player
        const action = hasVoted ? 'remove' : 'cast';
        sendVoteUpdate(card, parseInt(playerIdStr), action);
    }

    async function sendVoteUpdate(card, playerIdInt, action) {
        card.classList.add('saving'); // Show spinner visually
        card.style.cursor = 'wait'; // Change cursor while saving

        try {
            const response = await fetch(castVoteUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken, 'Accept': 'application/json' },
                body: JSON.stringify({ player_id: playerIdInt, action_request: action }),
            });

            if (!response.ok) {
                 let errorMsg = `Server error: ${response.status}`;
                 let errorData = {};
                 try { errorData = await response.json(); errorMsg = errorData.message || errorMsg; } catch(e) {/* ignore */}
                 // Special handling for limit reached error
                 if (errorData.status === 'limit_reached') {
                     showTemporaryMessage(card, errorData.message, true);
                     userVoteCount = errorData.user_vote_count !== undefined ? errorData.user_vote_count : 3;
                     updateVoteCounterUI(); // Update UI states for all cards
                     return; // Stop processing further for this specific error
                 }
                 throw new Error(errorMsg); // Throw for other errors
             }

            const data = await response.json();

            if (data.status === 'success') {
                // Update local state based on server response
                userVoteCount = data.user_vote_count;
                const playerIdStr = String(playerIdInt);
                if (data.voted === true) userVotes[playerIdStr] = 1; // Add vote locally
                else delete userVotes[playerIdStr]; // Remove vote locally

                // Update UI based on new local state
                updateVoteCounterUI(); // Updates counts and enables/disables cards globally

                // Update the specific card's score badge
                const scoreBadge = card.querySelector('.player-score-badge');
                if (scoreBadge && data.new_score !== undefined) {
                    scoreBadge.textContent = data.new_score;
                }
                showTemporaryMessage(card, data.message); // Show success message
            } else {
                 // Handle other potential non-success statuses from the server
                 throw new Error(data.message || 'Unknown server response.');
            }
        } catch (error) {
            console.error("Error casting vote:", error);
            showTemporaryMessage(card, `Error: ${error.message || 'Could not save vote.'}`, true);
            // Don't revert state on error, let next action/refresh fix
        } finally {
            card.classList.remove('saving');
            // Re-evaluate interaction based on the final state *after* the update
            const playerIdStr = String(playerIdInt);
            updateCardVoteState(card, playerIdStr); // Correctly sets cursor and class
        }
    }

    // --- Function and Listener for the Clear Votes Button ---
    async function sendClearVotesUpdate() {
        if (!confirm("Are you sure you want to remove all your votes for this prize?")) {
            return;
        }

        clearVotesBtn.disabled = true;
        clearVotesBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Clearing...';

        try {
            const response = await fetch(clearVotesUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken, 'Accept': 'application/json' },
                // No body needed for clearing all votes
            });

            if (!response.ok) {
                let errorMsg = `Server error: ${response.status}`;
                try { const errorData = await response.json(); errorMsg = errorData.message || errorMsg; } catch(e) {/* ignore */}
                throw new Error(errorMsg);
            }

            const data = await response.json();

            if (data.status === 'success') {
                // Reset local state
                userVotes = {};
                userVoteCount = 0;

                // Update scores from server response
                if (data.updated_scores && Array.isArray(data.updated_scores)) {
                    data.updated_scores.forEach(item => {
                        const scoreBadge = document.getElementById(`score-${item.player_id}`);
                        if (scoreBadge) {
                            scoreBadge.textContent = item.new_score;
                        }
                    });
                }

                // Update all card UI (removes green borders, re-enables all cards)
                updateVoteCounterUI();

                // Show a success message (e.g., near the button or on the first card)
                showTemporaryMessage(clearVotesBtn.closest('.d-flex'), data.message || "Votes cleared!"); // Show near button
            } else {
                throw new Error(data.message || 'Unknown server error.');
            }

        } catch (error) {
            console.error("Error clearing votes:", error);
            // Show error message near the button
             showTemporaryMessage(clearVotesBtn.closest('.d-flex'), `Error: ${error.message}`, true);
        } finally {
            // Restore button text and re-evaluate disabled state
            clearVotesBtn.innerHTML = '<i class="bi bi-trash me-1"></i> Clear My Votes';
            updateVoteCounterUI(); // Re-checks if button should be disabled
        }
    }

    // Add listener only if the button exists and voting is allowed
    if (clearVotesBtn && votingAllowed) {
        clearVotesBtn.addEventListener('click', sendClearVotesUpdate);
    }


    // --- Search Filter ---
    function filterPlayers() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        if (!otherPlayersGrid) return;
        otherPlayersGrid.querySelectorAll('.player-card').forEach(card => {
            const playerName = card.dataset.playerName || '';
            const isVisible = playerName.includes(searchTerm);
            card.style.display = isVisible ? 'flex' : 'none'; // Use flex for card layout
        });
    }

    if (searchInput) {
        searchInput.addEventListener('input', filterPlayers);
    }

    // --- Run Initialization ---
    initializeCards(leadersGrid);
    initializeCards(otherPlayersGrid);
    console.log("Card initialization complete.");

});
</script>
{% endblock %}
