{% extends "base.html" %}
{% load static %}

{% block title %}{{ page_title }} - SquashSync{% endblock %}

{% block extra_head %}
<style>
    /* Grid for both leaders and other players */
    .player-vote-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); /* Slightly narrower cards */
        gap: 1.5rem;
        margin-top: 1rem;
    }
    .player-card {
        border: 2px solid var(--border-color);
        border-radius: 8px;
        background-color: var(--container-bg);
        text-align: center;
        transition: all 0.2s ease;
        position: relative;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        padding-bottom: 10px; /* Reduced padding */
        min-height: 220px; /* Adjusted height */
    }
    .player-card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: var(--link-color);
    }
    .player-card.disabled { /* Style for when vote limit reached */
        cursor: not-allowed;
        opacity: 0.7;
    }
    .player-card-content { padding: 1rem 1rem 0.5rem 1rem; flex-grow: 1; }
    .player-photo img, .player-photo .photo-placeholder {
        width: 80px; height: 80px; border-radius: 50%; margin: 0 auto 0.75rem; display: block;
        background-color: var(--container-light-bg); border: 2px solid var(--border-light);
    }
    .player-photo img { object-fit: cover; object-position: top; }
    .photo-placeholder { display: flex; align-items: center; justify-content: center; }
    .photo-placeholder .bi { font-size: 2.5rem; color: #adb5bd; }
    .player-name { font-weight: 600; font-size: 1rem; margin-bottom: 0.25rem; }

    /* Score Badge */
    .player-score-badge {
        position: absolute; top: 10px; right: 10px; background-color: var(--bs-primary);
        color: white; border-radius: 50%; width: 28px; height: 28px;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 0.8em;
    }
    /* Vote Details (collapsible) */
    .vote-details { margin-top: 0.5rem; text-align: left; font-size: 0.8em; }
    .vote-details summary { cursor: pointer; color: var(--link-color); font-weight: 500;}
    .vote-details ul { list-style-type: none; padding-left: 0.5rem; margin-top: 0.25rem; }
    .vote-details li { margin-bottom: 0.25rem; }

    /* Vote Highlighting */
    .player-card.voted-by-user {
        border-color: var(--bs-success); /* Green border */
        background-color: var(--bs-success-bg-subtle);
    }
    html.dark-mode .player-card.voted-by-user {
         background-color: #032816;
         border-color: #20c997;
    }

    /* Spinner */
    .vote-spinner { position: absolute; top: 5px; left: 5px; width: 20px; height: 20px; border: 2px solid rgba(var(--bs-primary-rgb), 0.3); border-top-color: var(--bs-primary); border-radius: 50%; animation: spin 1s linear infinite; display: none; }
    .player-card.saving .vote-spinner { display: block; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Other Eligible Players Section */
    .other-players-section { margin-top: 3rem; }
    .search-input { max-width: 400px; margin-bottom: 1rem; }

    /* Winner Display */
    .winner-banner { background-color: var(--bs-success-bg-subtle); border-left: 5px solid var(--bs-success); padding: 1rem; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 1rem;}
    .winner-banner i { font-size: 2rem; color: var(--bs-success); }
    .winner-banner strong { font-size: 1.2rem; }

    /* Vote Counter */
    #vote-counter {
        font-weight: bold;
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        background-color: var(--bs-secondary-bg);
        border: 1px solid var(--bs-border-color);
        display: inline-block; /* Makes background fit content */
        margin-top: 5px; /* Add some space */
    }
    #vote-counter.limit-reached {
        background-color: var(--bs-warning-bg-subtle);
        border-color: var(--bs-warning-border-subtle);
        color: var(--bs-warning-text);
    }
    /* Simple feedback message styling */
    .vote-feedback {
        position: absolute; bottom: 5px; left: 5px; right: 5px; font-size: 0.75rem;
        padding: 2px 5px; border-radius: 3px; opacity: 0; transition: opacity 0.5s ease-out;
        z-index: 10; /* Ensure it's above other elements if needed */
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4" id="awards-vote-page" data-prize-id="{{ prize.id }}" data-cast-vote-url="{% url 'awards:cast_vote_ajax' %}">
    {# --- Header & Prize Info --- #}
    <div class="d-flex justify-content-between align-items-center mb-2">
        <div>
            <h1><i class="bi bi-person-check-fill me-2"></i>{{ page_title }}</h1>
            <p class="text-muted mb-1">{{ prize.description|default:"No description available." }}</p>
            <p class="mb-1"><strong>Status:</strong> {{ prize.get_status_display }}</p>
            {% if prize.voting_start_date and prize.voting_end_date %}
                <p class="mb-1"><strong>Voting Period:</strong> {{ prize.voting_start_date|date:"d M Y" }} to {{ prize.voting_end_date|date:"d M Y" }}</p>
            {% endif %}
        </div>
        <div>
            <a href="{% url 'awards:prize_list' %}?year={{ prize.year }}" class="btn btn-outline-secondary">
                <i class="bi bi-arrow-left"></i> Back to Prize List
            </a>
            {# Removed Edit Nominations link #}
        </div>
    </div>

    {# --- Winner Display --- #}
    {% if winner %}
    <div class="winner-banner rounded">
        <i class="bi bi-trophy-fill"></i>
        <div>
            <strong>Winner Decided: {{ winner.player.full_name }}</strong><br>
            Awarded on {{ winner.award_date|date:"d M Y" }} by {{ winner.awarded_by.get_full_name|default:winner.awarded_by.username }}.
            (Final Score: {{ winner.final_score|default:"N/A" }})
        </div>
    </div>
    {% endif %}

    {# --- Voting Instructions / Status --- #}
    {% if not current_results and not eligible_not_voted_players %}
        <div class="alert alert-warning mt-4" role="alert">
            No players are eligible for this prize based on the criteria (Grade {{ prize.min_grade|default:"Any" }} - {{ prize.max_grade|default:"Any" }}).
        </div>
    {% elif not voting_allowed and not winner %}
         <div class="alert alert-info mt-4" role="alert">
             Voting is not currently open. It {% if prize.voting_start_date %}starts {{ prize.voting_start_date|date:"d M Y" }}{% else %}will open soon{% endif %}.
         </div>
    {% elif voting_allowed %}
        <p class="lead mt-3">Click on a player's card to cast or remove your vote.</p>
        <p>You can cast up to 3 votes in total for this prize.
            <span id="vote-counter">Votes Used: {{ user_vote_count }} / 3</span>
        </p>
    {% endif %}


    {# --- Current Leaders Section --- #}
    {% if current_results %}
        <h3 class="mt-4">Current Leaders</h3>
        <div class="player-vote-grid" id="leaders-grid">
            {% for result in current_results %}
                <div class="player-card" data-player-id="{{ result.player.id }}" tabindex="0">
                    <div class="player-score-badge" id="score-{{ result.player.id }}">{{ result.score }}</div>
                    <div class="vote-spinner" id="spinner-{{ result.player.id }}"></div>
                    <div class="player-card-content">
                        <div class="player-photo">
                            {% if result.player.photo %}
                                <img src="{{ result.player.photo.url }}" alt="Photo of {{ result.player.full_name }}">
                            {% else %}
                                <div class="photo-placeholder"><i class="bi bi-person-fill"></i></div>
                            {% endif %}
                        </div>
                        <div class="player-name">{{ result.player.full_name }}</div>

                        {% if result.votes_by_voter %}
                            <details class="vote-details">
                                <summary>View Votes ({{ result.vote_count }})</summary>
                                <ul>
                                    {% for vote in result.votes_by_voter.voters %} {# Adjusted loop based on new structure #}
                                        <li>{{ vote.voter }}</li>
                                    {% endfor %}
                                </ul>
                            </details>
                        {% endif %}
                    </div> {# End player-card-content #}
                    {# Vote controls removed from here #}
                </div> {# End player-card #}
            {% endfor %}
        </div>
    {% endif %} {# End if current_results #}


    {# --- Other Eligible Players Section --- #}
    {% if eligible_not_voted_players %}
        <div class="other-players-section">
            <h3 class="mt-4">Other Eligible Players</h3>
            <input type="text" id="player-search" class="form-control search-input" placeholder="Search eligible players...">
            <div class="player-vote-grid" id="other-players-grid">
                {% for player in eligible_not_voted_players %}
                    <div class="player-card" data-player-id="{{ player.id }}" tabindex="0" data-player-name="{{ player.full_name|lower }}">
                        <div class="player-score-badge" id="score-{{ player.id }}">0</div>
                        <div class="vote-spinner" id="spinner-{{ player.id }}"></div>
                        <div class="player-card-content">
                            <div class="player-photo">
                                {% if player.photo %}
                                    <img src="{{ player.photo.url }}" alt="Photo of {{ player.full_name }}">
                                {% else %}
                                    <div class="photo-placeholder"><i class="bi bi-person-fill"></i></div>
                                {% endif %}
                            </div>
                            <div class="player-name">{{ player.full_name }}</div>
                            {# No vote details initially #}
                        </div> {# End player-card-content #}
                        {# Vote controls removed from here #}
                    </div> {# End player-card #}
                {% endfor %}
            </div>
        </div>
    {% endif %} {# End if eligible_not_voted_players #}


    {# --- Admin Winner Confirmation Section --- #}
    {# Use the simple boolean flag passed from the view #}
    {% if show_admin_confirm_section %}
        <hr class="my-5">
        <div class="card shadow-sm mt-4 bg-light">
            <div class="card-header bg-secondary text-white">
                <i class="bi bi-award-fill me-1"></i> Admin: Confirm Winner
            </div>
            <div class="card-body">
                <form method="post" action="{% url 'awards:confirm_winner' prize.id %}">
                    {% csrf_token %}
                    <p>Select the final winner for this prize based on votes or admin decision:</p>
                    {% comment %} Combine results and other players for the selection list {% endcomment %}
                    {% for result in current_results %}
                        <div class="form-check mb-2">
                            <input class="form-check-input" type="radio" name="winner_player_id"
                                   id="winner_{{ result.player.id }}" value="{{ result.player.id }}" required>
                            <label class="form-check-label" for="winner_{{ result.player.id }}">
                                {{ result.player.full_name }} (Current Score: {{ result.score }})
                            </label>
                        </div>
                    {% endfor %}
                    {% for player in eligible_not_voted_players %}
                         <div class="form-check mb-2">
                            <input class="form-check-input" type="radio" name="winner_player_id"
                                   id="winner_{{ player.id }}" value="{{ player.id }}" required>
                            <label class="form-check-label" for="winner_{{ player.id }}">
                                {{ player.full_name }} (Current Score: 0)
                            </label>
                        </div>
                    {% endfor %}

                    <button type="submit" class="btn btn-success mt-3"
                            onclick="return confirm('Are you sure you want to confirm this winner? This will change the prize status to Decided and close voting.')">
                        <i class="bi bi-check-circle-fill me-1"></i> Confirm Winner & Close Voting
                    </button>
                </form>
            </div>
        </div>
    {% endif %} {# End Admin Winner Section #}


</div> {# End container #}

{# Pass initial user votes to JavaScript #}
{{ user_votes_simple_json|json_script:"user-votes-data" }}
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const pageContainer = document.getElementById('awards-vote-page');
    if (!pageContainer) return;

    const prizeId = pageContainer.dataset.prizeId;
    const castVoteUrl = pageContainer.dataset.castVoteUrl;
    const leadersGrid = document.getElementById('leaders-grid');
    const otherPlayersGrid = document.getElementById('other-players-grid');
    const searchInput = document.getElementById('player-search');
    const voteCounterElement = document.getElementById('vote-counter');
    let userVotes = {}; // Will store { player_id: 1 } if voted
    let userVoteCount = 0;
    const votingAllowed = {{ voting_allowed|yesno:"true,false" }};

    try {
        userVotes = JSON.parse(document.getElementById('user-votes-data').textContent);
        userVoteCount = Object.keys(userVotes).length; // Initial count
        updateVoteCounterUI(); // Update counter on load
    } catch (e) {
        console.error("Could not parse user votes data:", e);
    }

    function getCookie(name) { /* ... CSRF token function ... */
        let cookieValue = null; if (document.cookie && document.cookie !== '') { const cookies = document.cookie.split(';'); for (let i = 0; i < cookies.length; i++) { const cookie = cookies[i].trim(); if (cookie.substring(0, name.length + 1) === (name + '=')) { cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; } } } return cookieValue;
     }
    const csrfToken = getCookie('csrftoken');

    // --- Initialization ---
    function initializeCards(grid) {
        if (!grid) return;
        grid.querySelectorAll('.player-card').forEach(card => {
            const playerId = parseInt(card.dataset.playerId);
            updateCardVoteState(card, playerId);

            if (votingAllowed) {
                // Click listener for the whole card
                card.addEventListener('click', (event) => {
                    // Prevent clicks on details toggling vote
                    if (event.target.closest('.vote-details')) return;
                    handleCardClick(card, playerId);
                });
            } else {
                 card.style.cursor = 'default'; // No pointer if voting closed
            }
        });
    }

    // --- UI Update Functions ---
    function updateCardVoteState(card, playerId) {
        const hasVoted = userVotes.hasOwnProperty(playerId);
        card.classList.toggle('voted-by-user', hasVoted);

        // Disable clicking other cards if limit is reached and this card isn't voted
        const limitReached = userVoteCount >= 3;
        card.classList.toggle('disabled', limitReached && !hasVoted);
        // Only make cursor not-allowed if voting is generally allowed but limit reached for this card
        if (votingAllowed) {
            card.style.cursor = (limitReached && !hasVoted) ? 'not-allowed' : 'pointer';
        } else {
            card.style.cursor = 'default'; // Always default if voting closed
        }
    }

    function updateVoteCounterUI() {
        if (voteCounterElement) {
            voteCounterElement.textContent = `Votes Used: ${userVoteCount} / 3`;
            voteCounterElement.classList.toggle('limit-reached', userVoteCount >= 3);
        }
        // Update disabled state for all cards
         [leadersGrid, otherPlayersGrid].forEach(grid => {
            if (!grid) return;
            grid.querySelectorAll('.player-card').forEach(card => {
                const playerId = parseInt(card.dataset.playerId);
                updateCardVoteState(card, playerId); // Re-apply state based on new count
            });
         });
    }

    // --- Event Handlers & AJAX ---
    function handleCardClick(card, playerId) {
        if (!votingAllowed) return; // Double check
        // Prevent action if limit reached and clicking a card user hasn't voted for
        if (userVoteCount >= 3 && !userVotes.hasOwnProperty(playerId)) {
            showTemporaryMessage(card, "Vote limit reached! Remove another vote first.", true);
            return;
        }

        const hasVoted = userVotes.hasOwnProperty(playerId);
        const action = hasVoted ? 'remove' : 'cast';

        sendVoteUpdate(card, playerId, action);
    }

    async function sendVoteUpdate(card, playerId, action) {
        card.classList.add('saving');
        try {
            const response = await fetch(castVoteUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken, 'Accept': 'application/json' },
                body: JSON.stringify({ prize_id: prizeId, player_id: playerId, action: action }),
            });
            const data = await response.json();

            if (data.status === 'success') {
                // Update local state first (crucial before UI updates depending on count)
                updateLocalUserVotes(playerId, action); // Update userVotes object
                userVoteCount = data.user_vote_count; // Sync count with server response

                // Update UI based on new local state
                updateCardVoteState(card, playerId); // Update the clicked card
                updateVoteCounterUI(); // Update counter and potentially disable/enable other cards

                // Update score badge
                const scoreBadge = card.querySelector('.player-score-badge');
                if (scoreBadge && data.new_score !== undefined) {
                    scoreBadge.textContent = data.new_score;
                }
                showTemporaryMessage(card, data.message);

                // --- Optional: Move card between grids (Add later if needed) ---

            } else if (data.status === 'limit_reached') {
                 showTemporaryMessage(card, data.message, true); // Show limit message
                 userVoteCount = 3; // Ensure local count is synced
                 updateVoteCounterUI(); // Update UI states
            } else {
                // Handle other specific errors if needed, otherwise throw generic
                 throw new Error(data.message || 'Unknown error from server.');
            }
        } catch (error) {
            console.error("Error casting vote:", error);
            showTemporaryMessage(card, `Error: ${error.message || 'Could not save vote.'}`, true);
             // Optionally revert local state if AJAX failed critically
             // revertLocalUserVotes(playerId, action); // Need to implement revert logic if desired
        } finally {
            card.classList.remove('saving');
        }
    }

    // Update local state *before* UI updates that depend on the count
    function updateLocalUserVotes(playerId, action) {
        const wasVoted = userVotes.hasOwnProperty(playerId);
        if (action === 'cast' && !wasVoted) {
            userVotes[playerId] = 1; // Add to voted set
        } else if (action === 'remove' && wasVoted) {
            delete userVotes[playerId]; // Remove from voted set
        }
        // userVoteCount is updated directly from server response in sendVoteUpdate
    }

     // Simple feedback mechanism
    function showTemporaryMessage(card, message, isError = false) {
         let feedbackEl = card.querySelector('.vote-feedback');
         if (!feedbackEl) {
             feedbackEl = document.createElement('div');
             feedbackEl.className = 'vote-feedback';
             // Apply styles via JS for simplicity here
             Object.assign(feedbackEl.style, {
                position: 'absolute', bottom: '5px', left: '5px', right: '5px',
                fontSize: '0.75rem', padding: '2px 5px', borderRadius: '3px',
                opacity: '0', transition: 'opacity 0.5s ease-out', zIndex: '10'
             });
             card.appendChild(feedbackEl);
         }
         feedbackEl.textContent = message;
         feedbackEl.style.backgroundColor = isError ? 'var(--bs-danger-bg-subtle)' : 'var(--bs-success-bg-subtle)';
         feedbackEl.style.color = isError ? 'var(--bs-danger-text)' : 'var(--bs-success-text)';
         // Force reflow before changing opacity for transition
         void feedbackEl.offsetWidth;
         feedbackEl.style.opacity = '1';

         setTimeout(() => {
             feedbackEl.style.opacity = '0';
         }, 2500); // Hide after 2.5 seconds
     }


    // --- Search Filter ---
    function filterPlayers() {
        const searchTerm = searchInput.value.toLowerCase();
        if (!otherPlayersGrid) return;
        otherPlayersGrid.querySelectorAll('.player-card').forEach(card => {
            const playerName = card.dataset.playerName || '';
            const isVisible = playerName.includes(searchTerm);
            card.style.display = isVisible ? 'flex' : 'none'; // Use flex for display
        });
    }

    if (searchInput) {
        searchInput.addEventListener('input', filterPlayers);
    }

    // --- Run Initialization ---
    initializeCards(leadersGrid);
    initializeCards(otherPlayersGrid);

});
</script>
{% endblock %}

